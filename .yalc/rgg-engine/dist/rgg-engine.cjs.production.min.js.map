{"version":3,"file":"rgg-engine.cjs.production.min.js","sources":["../src/physics/types.ts","../src/physics/PhysicsProvider.context.ts","../src/utils/time.ts","../src/physics/config.ts","../src/physics/PhysicsConsumer.context.ts","../src/utils/ids.ts","../src/generic.tsx","../src/keys.tsx","../src/physics/helpers/planckjs/types.ts","../src/physics/PhysicsConsumer.tsx","../src/physics/PhysicsProvider.tsx","../src/physics/physicsLoopWorker.ts","../src/physics/Physics.tsx","../src/physics/helpers/planckjs/PlanckPhysicsHandler.context.ts","../src/physics/helpers/planckjs/PlanckApp.context.ts","../src/physics/helpers/planckjs/WorkerSubscription.tsx","../src/physics/helpers/planckjs/PlanckPhysicsWorkerMessagesHandler.tsx","../src/physics/helpers/planckjs/bodies.ts","../src/utils/numbers.ts","../src/physics/helpers/planckjs/updates.ts","../src/physics/helpers/planckjs/buffers.ts","../src/physics/helpers/planckjs/PlanckPhysicsHandler.tsx","../src/physics/PhysicsConsumerSyncMeshes.tsx","../src/physics/helpers/planckjs/PhysicsConsumerHelpers.tsx","../src/physics/helpers/planckjs/hooks.ts","../src/physics/helpers/cannon/CannonPhysicsWorkerMessagesHandler.tsx","../src/physics/helpers/cannon/bodies.ts","../src/physics/helpers/cannon/updates.ts","../src/physics/helpers/cannon/buffers.ts","../src/physics/helpers/cannon/CannonPhysicsHandler.tsx","../src/physics/helpers/cannon/hooks.ts","../node_modules/regenerator-runtime/runtime.js","../src/physics/helpers/rapier3d/updates.ts","../src/physics/helpers/rapier3d/bodies.ts","../src/physics/helpers/rapier3d/custom.ts","../src/physics/helpers/rapier3d/Rapier3DPhysicsWorkerMessagesHandler.tsx","../src/physics/helpers/rapier3d/Rapier3DPhysicsHandler.tsx","../src/physics/helpers/cannon/CannonApp.tsx","../src/physics/helpers/cannon/CannonPhysicsConsumer.tsx","../src/physics/helpers/planckjs/PlanckApp.tsx","../src/physics/helpers/planckjs/PlanckPhysicsConsumer.tsx","../src/physics/helpers/rapier3d/Rapier3DApp.tsx","../src/physics/helpers/rapier3d/Rapier3DPhysicsConsumer.tsx","../src/createWorkerApp.ts","../src/physics/helpers/rapier3d/hooks.ts"],"sourcesContent":["import {MutableRefObject} from \"react\";\nimport {Object3D} from \"three\";\n\nexport type OnWorldStepFn = (delta: number) => void\n\nexport enum WorkerMessageType {\n    PHYSICS_UPDATE,\n    PHYSICS_PROCESSED,\n    PHYSICS_READY,\n    PHYSICS_SET_PAUSED,\n    PHYSICS_ACKNOWLEDGED,\n    ADD_BODY,\n    REMOVE_BODY,\n    MODIFY_BODY,\n    CUSTOM\n}\n\nexport type WorkerMessageData = {\n    type: WorkerMessageType,\n    data?: any,\n    [key: string]: any,\n}\n\nexport type BodyData = {\n    ref: MutableRefObject<Object3D>,\n    index: number,\n    position?: [number, number] | [number, number, number],\n    angle?: number | [number, number, number, number],\n    previous: {\n        position?: [number, number] | [number, number, number],\n        angle?: number | [number, number, number, number],\n    },\n    lastUpdate: number,\n    lastRender: number,\n    applyRotation?: boolean,\n}","import {createContext, useContext} from \"react\";\n\ntype State = {}\n\nexport const Context = createContext(null as unknown as State)\n\nexport const usePhysicsContext = () => {\n    return useContext(Context)\n}","const start = Date.now()\n\nexport const getNow = () => {\n    return start + performance.now()\n}","export const DEFAULT_STEP_RATE = 1000 / 60","import {createContext, MutableRefObject, useContext} from \"react\";\nimport {Object3D} from \"three\";\n\ntype State = {\n    syncBody: (id: string, ref: MutableRefObject<Object3D>, applyRotation?: boolean) => () => void,\n    syncMeshes: () => void,\n    sendMessage: (message: any) => void,\n}\n\nexport const Context = createContext(null as unknown as State)\n\nexport const usePhysicsConsumerContext = () => useContext(Context)","import { MathUtils } from 'three';\n\nexport const generateUUID = MathUtils.generateUUID;","import React, {createContext, useCallback, useContext, useEffect, useRef, useState} from \"react\"\nimport {generateUUID} from \"./utils/ids\";\nimport {WorkerMessageData, WorkerMessageType} from \"./physics/types\";\nimport {useHandleKeyEvents} from \"./keys\";\n\nenum MessageType {\n    mounted = 'mounted',\n    unmounted = 'unmounted',\n    propUpdate = 'propUpdate',\n    propRemoved = 'propRemoved',\n}\n\ntype Message = {\n    message: MessageType,\n    id: string,\n    [key: string]: any,\n}\n\nconst useSyncComponent = (type: string, id: string, props: any, sendMessage: any) => {\n\n    useEffect(() => {\n        sendMessage({\n            message: MessageType.mounted,\n            id,\n            type,\n            value: props,\n        })\n        return () => {\n            sendMessage({\n                message: MessageType.unmounted,\n                id,\n            })\n        }\n    }, [type, id, sendMessage])\n\n}\n\nconst SyncedComponentProp: React.FC<{\n    id: string,\n    propKey: string,\n    value: any,\n    sendMessage: any,\n}> = ({propKey, id, value, sendMessage}) => {\n    const firstUpdateRef = useRef(true)\n    useEffect(() => {\n        if (firstUpdateRef.current) {\n            firstUpdateRef.current = false\n            return\n        }\n        sendMessage({\n            message: MessageType.propUpdate,\n            id,\n            value,\n            propKey,\n        })\n    }, [value, id, propKey])\n    useEffect(() => {\n        return () => {\n            sendMessage({\n                message: MessageType.propRemoved,\n                id,\n                propKey,\n            })\n        }\n    }, [id, propKey])\n    return null\n}\n\nexport const SyncedComponent: React.FC<{\n    [key: string]: any,\n    type: string,\n    id?: string,\n}> = ({type, id: passedId, ...props}) => {\n\n    const sendMessage = useWorkerSendMessage()\n\n    const [id] = useState(() => passedId ?? generateUUID())\n\n    useSyncComponent(type, id, props, sendMessage)\n\n    return (\n        <>\n            {\n                Object.entries(props).map(([key, value]) => (\n                    <SyncedComponentProp key={key} id={id} propKey={key} value={value} sendMessage={sendMessage}/>\n                ))\n            }\n        </>\n    )\n}\n\nconst Context = createContext<{\n    sendMessage: (message: any) => void,\n    worker: Worker,\n}>(null!)\n\nexport const useWorkerSendMessage = () => {\n    return useContext(Context).sendMessage\n}\n\nexport const useWorker = () => {\n    return useContext(Context).worker\n}\n\nexport const WorkerMessaging: React.FC<{\n    worker: Worker\n}> = ({worker, children}) => {\n\n    const sendMessage = useCallback((message: any) => {\n        worker.postMessage({\n            type: WorkerMessageType.CUSTOM,\n            message,\n        })\n    }, [worker])\n\n    useHandleKeyEvents(worker)\n\n    return (\n        <Context.Provider value={{sendMessage, worker}}>\n            {children}\n        </Context.Provider>\n    )\n\n}\n\nexport const SyncComponents: React.FC<{\n    components: {\n        [key: string]: any,\n    }\n}> = ({components}) => {\n\n\n    const worker = useWorker()\n\n    const [storedComponents, setComponents] = useState<{\n        [key: string]: {\n            id: string,\n            type: string,\n            props: {\n                [key: string]: any,\n            }\n        }\n    }>({})\n\n    const handleCustomMessage = useCallback((message: Message) => {\n        const {id, type, value, propKey} = message\n        switch (message.message) {\n            case MessageType.mounted:\n                setComponents(state => ({\n                    ...state,\n                    [id]: {\n                        id,\n                        type,\n                        props: value,\n                    }\n                }))\n                break;\n            case MessageType.unmounted:\n                setComponents(state => {\n                    const updated = {\n                        ...state,\n                    }\n                    delete updated[id]\n                    return updated\n                })\n                break;\n            case MessageType.propUpdate:\n                setComponents(state => {\n                    const existing = state[id] ?? {\n                        props: {},\n                    }\n                    return {\n                        ...state,\n                        [id]: {\n                            ...existing,\n                            props: {\n                                ...existing.props,\n                                [propKey]: value,\n                            }\n                        }\n                    }\n                })\n                break;\n            case MessageType.propRemoved:\n                setComponents(state => {\n                    const existing = state[id] ?? {\n                        props: {},\n                    }\n                    const updatedProps = {\n                        ...existing.props\n                    }\n                    delete updatedProps[propKey]\n                    return {\n                        ...state,\n                        [id]: {\n                            ...existing,\n                            props: updatedProps,\n                        }\n                    }\n                })\n                break;\n        }\n    }, [])\n\n    useEffect(() => {\n        const previousOnMessage = worker.onmessage\n\n        worker.onmessage = (event: any) => {\n\n            if (previousOnMessage) {\n                // @ts-ignore\n                previousOnMessage(event)\n            }\n\n            const message = event.data as WorkerMessageData\n\n            if (message.type === WorkerMessageType.CUSTOM) {\n                handleCustomMessage(message.message as Message)\n            }\n\n        }\n\n        return () => {\n            worker.onmessage = previousOnMessage\n        }\n\n    }, [])\n\n    return (\n        <>\n            {\n                Object.entries(storedComponents).map(([key, component]) => {\n                    const Component = components[component.type]\n                    if (!Component) return null\n                    return <Component id={key} {...component.props} key={key}/>\n                })\n            }\n        </>\n    )\n}","import {useEffect} from \"react\";\nimport create from \"zustand\";\n\nexport const useTransferKeyEvents = (worker: Worker) => {\n\n    useEffect(() => {\n        const onKeyDown = (event: KeyboardEvent) => {\n            if (event.repeat) return\n            const {\n                code,\n                key,\n                keyCode\n            } = event\n            worker.postMessage({\n                type: 'KEYDOWN',\n                data: {\n                    code,\n                    key,\n                    keyCode,\n                }\n            })\n        }\n        const onKeyUp = (event: KeyboardEvent) => {\n            const {\n                code,\n                key,\n                keyCode\n            } = event\n            worker.postMessage({\n                type: 'KEYUP',\n                data: {\n                    code,\n                    key,\n                    keyCode,\n                }\n            })\n        }\n        window.addEventListener('keydown', onKeyDown)\n        window.addEventListener('keyup', onKeyUp)\n\n        return () => {\n            window.removeEventListener('keydown', onKeyDown)\n            window.removeEventListener('keyup', onKeyUp)\n        }\n\n    }, [])\n\n}\n\nexport const useActiveKeys = create<{\n    activeKeys: {\n        [key: number]: boolean,\n    }\n}>(() => ({\n    activeKeys: {},\n}))\n\nexport const rawActiveKeys: {\n    [key: number]: boolean,\n} = {}\n\nconst setActiveKey = (code: number, active: boolean) => {\n    rawActiveKeys[code] = active\n    return useActiveKeys.setState(state => ({\n        activeKeys: {\n            ...state.activeKeys,\n            [code]: active,\n        }\n    }))\n}\n\nexport const useHandleKeyEvents = (worker: Worker) => {\n\n    useEffect(() => {\n\n        const previousOnMessage = worker.onmessage as any\n\n        worker.onmessage = (event: any) => {\n\n            if (previousOnMessage) {\n                previousOnMessage(event)\n            }\n\n            const data = event.data\n\n            switch (data.type) {\n                case 'KEYUP':\n                    setActiveKey(data.data.keyCode, false)\n                    break;\n                case 'KEYDOWN':\n                    setActiveKey(data.data.keyCode, true)\n                    break;\n            }\n\n        }\n\n        return () => {\n            worker.onmessage = previousOnMessage\n        }\n\n    }, [worker])\n\n}","import {BodyDef, FixtureOpt} from \"planck-js\";\n\nexport type Buffers = {\n    positions: Float32Array;\n    angles: Float32Array;\n};\n\nexport enum FixtureShape {\n    Circle = 'Circle',\n    Box = 'Box',\n}\n\nexport type Fixtures = {\n    shape: FixtureShape,\n    args: any[],\n    fixtureOptions: Partial<FixtureOpt>,\n}[]\n\nexport type AddBodyDef = {\n    body: BodyDef,\n    fixtures: Fixtures\n}","import React, {\n    createContext,\n    MutableRefObject,\n    useCallback,\n    useContext,\n    useEffect,\n    useMemo,\n    useRef,\n    useState\n} from \"react\";\nimport {BodyData, WorkerMessageData, WorkerMessageType} from \"./types\";\nimport {getNow} from \"../utils/time\";\nimport {Object3D} from \"three\";\nimport {DEFAULT_STEP_RATE} from \"./config\";\nimport {Context} from \"./PhysicsConsumer.context\";\nimport {PhysicsConsumerSyncMeshes} from \"../index\";\nimport {WorkerMessaging} from \"../generic\";\nimport {useTransferKeyEvents} from \"../keys\";\n\nexport type DefaultPhysicsConsumerProps = {\n    worker: Worker,\n    stepRate?: number,\n    paused?: boolean,\n}\n\nconst FixedUpdateContext = createContext<{\n    onFixedUpdateSubscriptions: MutableRefObject<{\n        [key: string]: MutableRefObject<(delta: number) => void>,\n    }>,\n    subscribeToOnPhysicsUpdate: (callback: MutableRefObject<(delta: number) => void>) => () => void,\n    updateSubscriptions: (delta: number) => void,\n}>(null!)\n\nexport const useFixedUpdateContext = () =>{\n    return useContext(FixedUpdateContext)\n}\n\nexport const OnFixedUpdateProvider: React.FC = ({children}) => {\n\n    const localStateRef = useRef<{\n        subscriptionsIterator: number,\n    }>({\n        subscriptionsIterator: 0,\n    })\n\n    const onFixedUpdateSubscriptions = useRef<{\n        [key: string]: MutableRefObject<(delta: number) => void>,\n    }>({})\n\n    const {\n        subscribeToOnPhysicsUpdate,\n        updateSubscriptions,\n    } = useMemo(() => ({\n        subscribeToOnPhysicsUpdate: (callback: MutableRefObject<(delta: number) => void>) => {\n            const id = localStateRef.current.subscriptionsIterator.toString()\n            localStateRef.current.subscriptionsIterator += 1\n            onFixedUpdateSubscriptions.current[id] = callback\n            return () => {\n                delete onFixedUpdateSubscriptions.current[id]\n            }\n        },\n        updateSubscriptions: (delta: number) => {\n            Object.values(onFixedUpdateSubscriptions.current).forEach(callback => callback.current(delta))\n        }\n    }), [])\n\n    return (\n        <FixedUpdateContext.Provider value={{\n            onFixedUpdateSubscriptions,\n            subscribeToOnPhysicsUpdate,\n            updateSubscriptions,\n        }}>\n            {children}\n        </FixedUpdateContext.Provider>\n    )\n}\n\ntype Props = DefaultPhysicsConsumerProps & {\n    lerpBody: (body: BodyData, object: Object3D, stepRate: number) => void,\n    updateBodyData: (bodyData: BodyData, positions: Float32Array, angles: Float32Array) => void,\n}\n\nconst PhysicsConsumer: React.FC<Props> = ({\n            paused = false,\n          updateBodyData,\n          worker,\n          children,\n          stepRate = DEFAULT_STEP_RATE, lerpBody\n      }) => {\n\n    const [connected, setConnected] = useState(false)\n    const [bodiesData] = useState<{\n        [id: string]: BodyData\n    }>({})\n    const localStateRef = useRef<{\n        lastUpdate: number,\n        subscriptionsIterator: number,\n        bodies: string[],\n    }>({\n        lastUpdate: getNow(),\n        subscriptionsIterator: 0,\n        bodies: []\n    })\n\n    const {\n        updateSubscriptions,\n    } = useFixedUpdateContext()\n\n    const onFrameCallbacks = useRef<{\n        [id: string]: () => void,\n    }>({})\n\n    const lerpMesh = useCallback((body: BodyData, ref: MutableRefObject<Object3D>) => {\n        if (!ref.current) return\n        const object = ref.current\n        lerpBody(body, object, stepRate)\n    }, [])\n\n    const onUpdate = useCallback((updateTime: number, positions: Float32Array, angles: Float32Array, bodies: undefined | string[]) => {\n\n        if (bodies) {\n            localStateRef.current.bodies = bodies\n        }\n\n        Object.entries(bodiesData).forEach(([id, bodyData]) => {\n            if (bodies) {\n                bodyData.index = bodies.indexOf(id)\n            }\n            if (bodyData.index >= 0) {\n                updateBodyData(bodyData, positions, angles)\n                bodyData.lastUpdate = updateTime\n            }\n        })\n\n        const now = updateTime\n        const delta = (now - localStateRef.current.lastUpdate) / 1000\n        localStateRef.current.lastUpdate = now\n        updateSubscriptions(delta)\n\n    }, [updateSubscriptions])\n\n    useEffect(() => {\n        if (connected) return\n        const interval = setInterval(() => {\n            worker.postMessage({\n                type: WorkerMessageType.PHYSICS_READY,\n                paused,\n            })\n        }, 200)\n        return () => {\n            clearInterval(interval)\n        }\n    }, [connected, paused])\n\n    useEffect(() => {\n        worker.postMessage({\n            type: WorkerMessageType.PHYSICS_SET_PAUSED,\n            paused,\n        })\n    }, [paused])\n\n    useEffect(() => {\n\n        const previousOnMessage: any = worker.onmessage\n\n        worker.onmessage = (event: any) => {\n\n            const message = event.data as WorkerMessageData\n\n            switch (message.type) {\n                case WorkerMessageType.PHYSICS_ACKNOWLEDGED:\n                    setConnected(true)\n                    break;\n                case WorkerMessageType.PHYSICS_UPDATE:\n                    onUpdate(message.updateTime, message.positions, message.angles, message.bodies)\n\n                    worker.postMessage({\n                        type: WorkerMessageType.PHYSICS_PROCESSED,\n                        positions: message.positions,\n                        angles: message.angles,\n                    }, [message.positions.buffer, message.angles.buffer])\n                    break;\n            }\n\n            if (previousOnMessage) {\n                previousOnMessage(event)\n            }\n\n        }\n\n    }, [])\n\n    const {\n        syncBody,\n    } = useMemo(() => ({\n        syncBody: (id: string, ref: MutableRefObject<Object3D>, applyRotation: boolean = true) => {\n            localStateRef.current.subscriptionsIterator += 1\n            const body: BodyData = {\n                ref,\n                index: localStateRef.current.bodies.indexOf(id),\n                lastUpdate: getNow(),\n                lastRender: getNow(),\n                previous: {},\n                applyRotation,\n            }\n            bodiesData[id] = body\n            onFrameCallbacks.current[id] = () => lerpMesh(body, ref)\n            return () => {\n                delete onFrameCallbacks.current[id]\n                delete bodiesData[id]\n            }\n        }\n    }), [])\n\n    const syncMeshes = useCallback(() => {\n        Object.values(onFrameCallbacks.current).forEach(callback => callback())\n    }, [])\n\n    const sendMessage = useCallback((message: any) => {\n        worker.postMessage(message)\n    }, [])\n\n    useTransferKeyEvents(worker)\n\n    if (!connected) return null\n\n    return (\n        <WorkerMessaging worker={worker}>\n            <Context.Provider value={{\n                syncBody,\n                syncMeshes,\n                sendMessage,\n            }}>\n                <PhysicsConsumerSyncMeshes useRAF/>\n                {children}\n            </Context.Provider>\n        </WorkerMessaging>\n    );\n};\n\nconst Wrapper: React.FC<Props> = (props) => {\n    return (\n        <OnFixedUpdateProvider>\n            <PhysicsConsumer {...props}/>\n        </OnFixedUpdateProvider>\n    )\n}\n\nexport default Wrapper;","import React, {useEffect, useMemo, useRef} from \"react\";\nimport {Context} from \"./PhysicsProvider.context\";\nimport {OnWorldStepFn} from \"./types\";\nimport {createNewPhysicsLoopWebWorker} from \"./physicsLoopWorker\";\nimport {getNow} from \"../utils/time\";\nimport {useFixedUpdateContext} from \"./PhysicsConsumer\";\n\nlet now = 0\nlet delta = 0\n\nconst usePhysicsWorldStepHandler = (onWorldStep: OnWorldStepFn, stepRate: number, paused: boolean) => {\n\n    const localStateRef = useRef({\n        lastUpdate: getNow(),\n    })\n\n    const {\n        updateSubscriptions\n    } = useFixedUpdateContext()\n\n    const {\n        stepWorld\n    } = useMemo(() => ({\n        stepWorld: () => {\n            now = getNow()\n            delta = now - localStateRef.current.lastUpdate\n            localStateRef.current.lastUpdate = now\n            if (paused) return\n            onWorldStep(delta)\n            updateSubscriptions(delta / 1000)\n        }\n    }), [paused, onWorldStep, updateSubscriptions])\n\n    const stepWorldRef = useRef(stepWorld)\n\n    useEffect(() => {\n        stepWorldRef.current = stepWorld\n    }, [stepWorld])\n\n    useEffect(() => {\n        const worker = createNewPhysicsLoopWebWorker(stepRate)\n        // let lastStep = getNow()\n        worker.onmessage = (event) => {\n            if (event.data === 'step') {\n                // now = getNow()\n                // delta = now - lastStep\n                // lastStep = now\n                // console.log('delta', delta)\n                stepWorldRef.current()\n            }\n        }\n    }, [stepWorldRef])\n\n    return null\n}\n\nconst PhysicsProvider: React.FC<{\n    onWorldStep: OnWorldStepFn,\n    stepRate: number,\n}> = ({children, onWorldStep, stepRate}) => {\n\n    const paused = false\n    usePhysicsWorldStepHandler(onWorldStep, stepRate, paused)\n\n    return (\n        <Context.Provider value={{}}>\n            {children}\n        </Context.Provider>\n    );\n};\n\nexport default PhysicsProvider;","export const createNewPhysicsLoopWebWorker = (stepRate: number) => {\n    return new Worker('data:application/javascript,' +\n        encodeURIComponent(`\n            \n            var start = performance.now();\n            var updateRate = ${stepRate};\n            var maxAccumulator = updateRate;\n            \n            function getNow() {\n                return start + performance.now();\n            }\n            \n            var accumulator = 0;\n            var lastAccumulation = getNow();\n            var now = getNow();\n            var numberOfUpdates = 0;\n            \n            function accumulate() {\n                now = getNow();\n                accumulator += now - lastAccumulation;\n                lastAccumulation = now;\n                while (accumulator <= maxAccumulator) {\n                    now = getNow();\n                    accumulator += now - lastAccumulation;\n                    lastAccumulation = now;\n                }\n                numberOfUpdates = Math.floor(accumulator / maxAccumulator);\n                for (var i = 0; i < numberOfUpdates; i++) {\n                    self.postMessage('step');\n                    accumulator -= maxAccumulator;\n                }\n            }\n        \n            function step() {\n                \n                accumulate();\n                \n                setTimeout(step, updateRate - 2 - accumulator);\n                \n            }\n            \n            step()\n            \n        `) );\n}","import React from \"react\";\nimport PhysicsProvider from \"./PhysicsProvider\";\nimport {OnWorldStepFn} from \"./types\";\nimport {DEFAULT_STEP_RATE} from \"./config\";\nimport {OnFixedUpdateProvider} from \"./PhysicsConsumer\";\n\nconst Physics: React.FC<{\n    onWorldStep: OnWorldStepFn,\n    stepRate?: number,\n}> = ({children, onWorldStep, stepRate = DEFAULT_STEP_RATE}) => {\n    return (\n        <OnFixedUpdateProvider>\n            <PhysicsProvider onWorldStep={onWorldStep} stepRate={stepRate}>\n                {children}\n            </PhysicsProvider>\n        </OnFixedUpdateProvider>\n    );\n};\n\nexport default Physics;","import {createContext, useContext} from \"react\";\n\ntype State = {\n    getPendingSyncedBodiesIteration: () => number,\n    syncedBodies: {\n        [key: string]: any,\n    }\n    syncedBodiesOrder: string[],\n    maxNumberOfSyncedBodies: number,\n}\n\nexport const Context = createContext(null as unknown as State)\n\nexport const usePlanckPhysicsHandlerContext = () => useContext(Context)","import {createContext, useContext} from \"react\";\n\nexport type State = {\n    world: any,\n    addSyncedBody: (uid: string, body: any) => void,\n    removeSyncedBody: (uid: string) => void,\n    addBody: (id: string, body: any, synced?: boolean) => () => void,\n    bodies: {\n        [key: string]: any,\n    },\n}\n\nexport const Context = createContext(null as unknown as State)\n\nexport const usePlanckAppContext = () => useContext(Context)","import React, {useCallback, useEffect, useRef, useState} from \"react\";\nimport {usePlanckPhysicsHandlerContext} from \"./PlanckPhysicsHandler.context\";\nimport {getNow} from \"../../../utils/time\";\nimport {WorkerMessageData, WorkerMessageType} from \"../../types\";\nimport {ApplyBufferDataFn} from \"./updates\";\nimport {Buffers} from \"./types\";\n\nconst WorkerSubscription: React.FC<{\n    worker: Worker,\n    subscribe: (callback: () => void) => () => void,\n    applyBufferData: ApplyBufferDataFn,\n    generateBuffers: (maxNumberOfSyncedBodies: number) => Buffers,\n    setPaused?: (paused: boolean) => void,\n}> = ({worker, subscribe, applyBufferData, generateBuffers, setPaused}) => {\n\n    const {\n        getPendingSyncedBodiesIteration,\n        syncedBodies,\n        syncedBodiesOrder,\n        maxNumberOfSyncedBodies,\n    } = usePlanckPhysicsHandlerContext()\n\n    const [buffers] = useState(() => generateBuffers(maxNumberOfSyncedBodies))\n    const localStateRef = useRef({\n        lastUpdate: -1,\n        bodiesIteration: -1,\n    })\n    const [buffersAvailable, setBuffersAvailable] = useState(false)\n    const [updateCount, setUpdateCount] = useState(0)\n\n    const updateWorker = useCallback((update: number) => {\n        localStateRef.current.lastUpdate = update\n        setBuffersAvailable(false)\n\n        const bodiesIteration = getPendingSyncedBodiesIteration()\n        const shouldSyncBodies = bodiesIteration !== localStateRef.current.bodiesIteration\n\n        applyBufferData(buffers, syncedBodies, syncedBodiesOrder)\n\n        const {\n            positions,\n            angles,\n        } = buffers\n\n        const message: any = {\n            type: WorkerMessageType.PHYSICS_UPDATE,\n            updateTime: getNow(),\n            positions: positions,\n            angles: angles,\n        }\n\n        if (shouldSyncBodies) {\n            message.bodies = syncedBodiesOrder\n            localStateRef.current.bodiesIteration = bodiesIteration\n        }\n\n        worker.postMessage(message, [positions.buffer, angles.buffer])\n\n        // process local fixed updates\n\n    }, [getPendingSyncedBodiesIteration, syncedBodies, syncedBodiesOrder])\n\n    const updateWorkerRef = useRef(updateWorker)\n\n    useEffect(() => {\n        updateWorkerRef.current = updateWorker\n    }, [updateWorker])\n\n    useEffect(() => {\n        if (!buffersAvailable) return\n        if (updateCount <= localStateRef.current.lastUpdate) return\n        updateWorkerRef.current(updateCount)\n    }, [updateCount, buffersAvailable])\n\n    const onUpdate = useCallback(() => {\n        setUpdateCount(state => state + 1)\n    }, [])\n\n    const onUpdateRef = useRef(onUpdate)\n\n    useEffect(() => {\n        onUpdateRef.current = onUpdate\n    }, [onUpdate])\n\n    useEffect(() => {\n\n        return subscribe(() => onUpdateRef.current())\n\n    }, [])\n\n    useEffect(() => {\n        const previousOnMessage: any = worker.onmessage\n\n        worker.onmessage = (event: any) => {\n\n            const message = event.data as WorkerMessageData\n\n            switch (message.type) {\n                case WorkerMessageType.PHYSICS_PROCESSED:\n                    buffers.positions = message.positions\n                    buffers.angles = message.angles\n                    setBuffersAvailable(true)\n                    break;\n                case WorkerMessageType.PHYSICS_SET_PAUSED:\n                    if (setPaused) {\n                        setPaused(message.paused ?? false)\n                    }\n                    break;\n                case WorkerMessageType.PHYSICS_READY:\n                    if (setPaused) {\n                        setPaused(message.paused ?? false)\n                    }\n                    setBuffersAvailable(true)\n                    worker.postMessage({\n                        type: WorkerMessageType.PHYSICS_ACKNOWLEDGED,\n                    })\n                    break;\n            }\n\n            if (previousOnMessage) {\n                previousOnMessage(event)\n            }\n        }\n\n    }, [])\n\n    return null\n}\n\nexport default WorkerSubscription;","import React, {useEffect, useMemo} from \"react\"\nimport {WorkerMessageData, WorkerMessageType} from \"../../types\";\nimport {AddBodyDef} from \"./types\";\nimport {createBody} from \"./bodies\";\nimport {World} from \"planck-js\";\nimport {usePlanckAppContext} from \"./PlanckApp.context\";\n\nconst PlanckPhysicsWorkerMessagesHandler: React.FC<{\n    world: World,\n    worker: Worker,\n}> = ({\n    world,\n                                                    worker,\n                                                }) => {\n\n    const {\n        addBody,\n        bodies,\n    } = usePlanckAppContext()\n\n    const {\n        handleAddBody,\n        handleModifyBody,\n    } = useMemo(() => ({\n        handleModifyBody: ({id, method, args}: {\n            id: string,\n            method: string,\n            args: any[],\n        }) => {\n            const body = bodies[id]\n            if (!body) {\n                console.warn(`No body found matching ${id}`)\n                return\n            }\n            (body as any)[method](...args)\n        },\n        handleAddBody: ({id, props, synced}: {\n            id: string,\n            props: AddBodyDef,\n            synced: boolean,\n        }) => {\n\n            const body = createBody(world, props.body, props.fixtures)\n            addBody(id, body, synced)\n\n        }\n    }), [])\n\n    useEffect(() => {\n\n        const previousOnMessage: any = worker.onmessage\n\n        worker.onmessage = (event: any) => {\n\n            const message = event.data as WorkerMessageData\n\n            switch (message.type) {\n                case WorkerMessageType.ADD_BODY:\n                    handleAddBody(message.data)\n                    break;\n                case WorkerMessageType.MODIFY_BODY:\n                    handleModifyBody(message.data)\n                    break;\n            }\n\n            if (previousOnMessage) {\n                previousOnMessage(event)\n            }\n        }\n\n    }, [])\n\n    return null\n}\n\nexport default PlanckPhysicsWorkerMessagesHandler","import {BodyDef, Box, Circle, Shape, World} from \"planck-js\";\nimport {Fixtures, FixtureShape} from \"./types\";\n\nconst createFixtureShape = (shape: FixtureShape, args: any[]): Shape | null => {\n    switch (shape) {\n        case FixtureShape.Circle:\n            return Circle(...args)\n        case FixtureShape.Box:\n            // @ts-ignore\n            return Box(...args)\n    }\n    return null\n}\n\nexport const createBody = (world: World, bodyDef: BodyDef, fixtures: Fixtures) => {\n    const body = world.createBody(bodyDef)\n    fixtures.forEach(({shape, args, fixtureOptions}) => {\n        const fixtureShape = createFixtureShape(shape, args)\n        if (fixtureShape) {\n            body.createFixture(fixtureShape, fixtureOptions)\n        }\n    })\n    return body\n}","import { MathUtils } from 'three';\n\nexport const lerp = MathUtils.lerp;\n","import {AddBodyDef, Buffers} from \"./types\";\nimport {Body} from \"planck-js\";\nimport {getNow} from \"../../../utils/time\";\nimport {lerp} from \"../../../utils/numbers\";\nimport {Object3D} from \"three\";\nimport {BodyData} from \"../../types\";\n\nexport type ApplyBufferDataFn = (\n    buffers: Buffers,\n    syncedBodies: {\n        [key: string]: any,\n    },\n    syncedBodiesOrder: string[]\n) => void\n\nexport const lerpBody = (body: BodyData, object: Object3D, stepRate: number) => {\n\n    const {\n        position,\n        angle,\n        lastUpdate,\n        previous,\n        applyRotation = true,\n    } = body\n\n    if (!position || angle == undefined) {\n        return\n    }\n\n    if (!previous.position || !previous.angle) {\n        object.position.x = position[0]\n        object.position.z = position[1]\n        if (applyRotation) {\n            object.rotation.z = angle as number\n        }\n        return\n    }\n\n    const now = getNow()\n\n    const nextExpectedUpdate = lastUpdate + stepRate + 1\n\n    const min = lastUpdate\n    const max = nextExpectedUpdate\n\n    let normalised = ((now - min) / (max - min))\n\n    normalised = normalised < 0 ? 0 : normalised > 1 ? 1 : normalised\n\n    const physicsRemainingRatio = normalised\n\n    object.position.x = lerp(\n        previous.position[0],\n        position[0],\n        physicsRemainingRatio\n    );\n\n    object.position.y = lerp(\n        previous.position[1],\n        position[1],\n        physicsRemainingRatio\n    );\n\n    if (applyRotation) {\n        object.rotation.z = angle as number; // todo - lerp\n    }\n}\n\nconst getPositionAndAngle = (\n    buffers: Buffers,\n    index: number\n): {\n    position: [number, number];\n    angle: number;\n} | null => {\n    if (index !== undefined && buffers.positions.length && buffers.angles.length) {\n        const start = index * 2;\n        const position = (buffers.positions.slice(start, start + 2) as unknown) as [\n            number,\n            number\n        ];\n        return {\n            position,\n            angle: buffers.angles[index],\n        };\n    } else {\n        return null;\n    }\n};\n\nexport const updateBodyData = (bodyData: BodyData, positions: Float32Array, angles: Float32Array) => {\n    bodyData.previous.position = bodyData.position\n    bodyData.previous.angle = bodyData.angle\n    const update = getPositionAndAngle({\n        positions,\n        angles,\n    }, bodyData.index)\n    if (update) {\n        bodyData.position = update.position\n        bodyData.angle = update.angle\n    }\n}\n\nexport const applyBufferData = (\n    buffers: Buffers,\n    syncedBodies: {\n        [key: string]: Body,\n    }, syncedBodiesOrder: string[]) => {\n\n    const {\n        positions,\n        angles,\n    } = buffers\n\n    syncedBodiesOrder.forEach((id, index) => {\n        const body = syncedBodies[id]\n        if (!body) return;\n        const position = body.getPosition();\n        const angle = body.getAngle();\n        positions[2 * index + 0] = position.x;\n        positions[2 * index + 1] = position.y;\n        angles[index] = angle;\n    })\n\n}\n\nexport const prepareObject = (object: Object3D, props: AddBodyDef) => {\n    if (props.body.position) {\n        object.position.x = props.body.position.x\n        object.position.z = props.body.position.y\n    }\n    if (props.body.angle) {\n        object.rotation.z = props.body.angle\n    }\n}","import {Buffers} from \"./types\";\n\nexport const generateBuffers = (maxNumberOfPhysicsObjects: number): Buffers => {\n    return {\n        positions: new Float32Array(maxNumberOfPhysicsObjects * 2),\n        angles: new Float32Array(maxNumberOfPhysicsObjects),\n    };\n};\n","import React, {useCallback, useMemo, useRef, useState} from \"react\";\nimport {World, Body} from \"planck-js\";\nimport {Context} from \"./PlanckPhysicsHandler.context\";\nimport {Context as AppContext} from \"./PlanckApp.context\";\nimport Physics from \"../../Physics\";\nimport WorkerSubscription from \"./WorkerSubscription\";\nimport PlanckPhysicsWorkerMessagesHandler from \"./PlanckPhysicsWorkerMessagesHandler\";\nimport {applyBufferData} from \"./updates\";\nimport {generateBuffers} from \"./buffers\";\n\n\nexport const usePhysicsBodies = (removeBody: any) => {\n\n    const [bodies] = useState<{\n        [key: string]: any,\n    }>({})\n    const [syncedBodies] = useState<{\n        [key: string]: any,\n    }>({})\n    const [syncedBodiesOrder] = useState<string[]>([])\n    const hasPendingSyncedBodiesRef = useRef(0)\n\n    const getPendingSyncedBodiesIteration = useCallback(() => {\n        return hasPendingSyncedBodiesRef.current\n    }, [])\n\n    const addSyncedBody = useCallback((uid: string, body: any) => {\n        syncedBodiesOrder.push(uid)\n        syncedBodies[uid] = body\n        hasPendingSyncedBodiesRef.current += 1\n        return () => {\n            const index = syncedBodiesOrder.indexOf(uid)\n            syncedBodiesOrder.splice(index, 1)\n            delete syncedBodies[uid]\n            hasPendingSyncedBodiesRef.current += 1\n        }\n    }, [])\n\n    const removeSyncedBody = useCallback((uid: string) => {\n        const index = syncedBodiesOrder.indexOf(uid)\n        syncedBodiesOrder.splice(index, 1)\n        delete syncedBodies[uid]\n        hasPendingSyncedBodiesRef.current += 1\n    }, [])\n\n    const addBody = useCallback((uid: string, body: any, synced: boolean = false) => {\n        bodies[uid] = body\n        let syncedUnsub: any\n        if (synced) {\n            syncedUnsub = addSyncedBody(uid, body)\n        }\n        return () => {\n            delete bodies[uid]\n            if (syncedUnsub) {\n                syncedUnsub()\n            }\n            if (removeBody) {\n                removeBody(body)\n            }\n        }\n    }, [])\n\n    return {\n        addSyncedBody,\n        removeSyncedBody,\n        getPendingSyncedBodiesIteration,\n        syncedBodiesOrder,\n        syncedBodies,\n        addBody,\n        bodies,\n    }\n\n}\n\nexport const usePhysicsUpdate = () => {\n\n    const countRef = useRef(0)\n\n    const workerSubscriptionsRef = useRef<{\n        [key: string]: () => void,\n    }>({})\n\n    const subscribeToPhysicsUpdates = useCallback((callback: () => void) => {\n        const id = countRef.current.toString()\n        countRef.current += 1\n        workerSubscriptionsRef.current[id] = callback\n\n        return () => {\n            delete workerSubscriptionsRef.current[id]\n        }\n\n    }, [])\n\n    const onUpdate =  useCallback(() => {\n\n        Object.values(workerSubscriptionsRef.current).forEach(callback => callback())\n\n    }, [])\n\n    return {\n        onUpdate,\n        subscribeToPhysicsUpdates,\n    }\n\n}\n\nexport const usePhysics = (removeBody: any = () => {}) => {\n\n    const {\n        addSyncedBody,\n        removeSyncedBody,\n        getPendingSyncedBodiesIteration,\n        syncedBodies,\n        syncedBodiesOrder,\n        addBody,\n        bodies,\n    } = usePhysicsBodies(removeBody)\n\n    const {\n        onUpdate,\n        subscribeToPhysicsUpdates,\n    } = usePhysicsUpdate()\n\n    return {\n        subscribeToPhysicsUpdates,\n        getPendingSyncedBodiesIteration,\n        syncedBodies,\n        syncedBodiesOrder,\n        addSyncedBody,\n        removeSyncedBody,\n        addBody,\n        bodies,\n        onUpdate,\n    }\n}\n\nconst PlanckPhysicsHandler: React.FC<{\n    world: World,\n    worker: Worker,\n    stepRate: number,\n    maxNumberOfSyncedBodies: number,\n}> = ({children, world, worker, stepRate, maxNumberOfSyncedBodies}) => {\n\n    const removeBody = useCallback((body: Body) => {\n        world.destroyBody(body)\n    }, [])\n\n    const {\n        subscribeToPhysicsUpdates,\n        getPendingSyncedBodiesIteration,\n        syncedBodies,\n        syncedBodiesOrder,\n        addSyncedBody,\n        removeSyncedBody,\n        addBody,\n        bodies,\n        onUpdate,\n    } = usePhysics(removeBody)\n\n    const {\n        onWorldStep\n    } = useMemo(() => ({\n        onWorldStep: () => {\n            world.step(stepRate / 1000)\n            world.clearForces()\n            onUpdate()\n        }\n    }), [])\n\n    return (\n        <Context.Provider value={{\n            getPendingSyncedBodiesIteration,\n            syncedBodies,\n            syncedBodiesOrder,\n            maxNumberOfSyncedBodies,\n        }}>\n            <WorkerSubscription applyBufferData={applyBufferData} generateBuffers={generateBuffers}\n                                worker={worker} subscribe={subscribeToPhysicsUpdates}/>\n            <AppContext.Provider value={{\n                world,\n                addSyncedBody,\n                removeSyncedBody,\n                addBody,\n                bodies,\n            }}>\n                <PlanckPhysicsWorkerMessagesHandler world={world} worker={worker}/>\n                <Physics onWorldStep={onWorldStep} stepRate={stepRate}>\n                    {children}\n                </Physics>\n            </AppContext.Provider>\n        </Context.Provider>\n    );\n};\n\nexport default PlanckPhysicsHandler;","import React, {useEffect} from \"react\"\nimport {useFrame} from \"react-three-fiber\";\nimport {usePhysicsConsumerContext} from \"./PhysicsConsumer.context\";\n\nconst RAFSync: React.FC = () => {\n\n    const {syncMeshes} = usePhysicsConsumerContext()\n    useFrame(syncMeshes)\n\n    return null\n}\n\nconst IntervalSync: React.FC = () => {\n\n    const {syncMeshes} = usePhysicsConsumerContext()\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            syncMeshes()\n        }, 1000 / 30)\n        return () => {\n            clearInterval(interval)\n        }\n    }, [])\n\n    return null\n}\n\nconst PhysicsConsumerSyncMeshes: React.FC<{\n    useRAF?: boolean\n}> = ({\n    useRAF = false,\n}) => {\n    if (useRAF) return <RAFSync/>\n    return <IntervalSync/>\n}\n\nexport default PhysicsConsumerSyncMeshes","import React, {createContext, useContext} from \"react\"\nimport {Object3D} from \"three\";\n\ntype State = {\n    prepareObject: (object: Object3D, props: any) => void,\n}\n\nconst Context = createContext<State>(null as unknown as State)\n\nexport const usePhysicsConsumerHelpers = () => useContext(Context)\n\nconst PhysicsConsumerHelpers: React.FC<{\n    prepareObject: (object: Object3D, props: any) => void,\n}> = ({children, prepareObject}) => {\n    return (\n        <Context.Provider value={{prepareObject}}>\n            {children}\n        </Context.Provider>\n    )\n}\n\nexport default PhysicsConsumerHelpers","import {AddBodyDef} from \"./types\";\nimport {MutableRefObject, useCallback, useEffect, useLayoutEffect, useRef, useState} from \"react\";\nimport {generateUUID} from \"../../../utils/ids\";\nimport {usePhysicsConsumerContext} from \"../../PhysicsConsumer.context\";\nimport {WorkerMessageType} from \"../../types\";\nimport {Object3D} from \"three\";\nimport {usePhysicsConsumerHelpers} from \"./PhysicsConsumerHelpers\";\nimport {useFixedUpdateContext} from \"../../PhysicsConsumer\";\n\nexport const useOnFixedUpdate = (callback: (delta: number) => void) => {\n    const {\n        subscribeToOnPhysicsUpdate\n    } = useFixedUpdateContext()\n\n    const callbackRef = useRef(callback)\n\n    useEffect(() => {\n        callbackRef.current = callback\n    }, [callback])\n\n    useEffect(() => {\n        return subscribeToOnPhysicsUpdate(callbackRef)\n    }, [])\n\n}\n\nexport const useBodyApi = (id: string) => {\n    const {sendMessage} = usePhysicsConsumerContext()\n\n    return useCallback((method: string,\n                        args: any[],) => {\n        sendMessage({\n            type: WorkerMessageType.MODIFY_BODY,\n            data: {\n                id,\n                method,\n                args,\n            }\n        })\n    }, [])\n\n}\n\nexport type Options = {\n    id?: string,\n    synced?: boolean,\n    listenForCollisions?: boolean,\n    ref?: MutableRefObject<Object3D>,\n}\n\nexport const useSyncBody = (id: string, ref: MutableRefObject<Object3D> | undefined, options?: {\n    applyRotation?: boolean,\n}) => {\n    const {\n        applyRotation = true\n    } = options ?? {}\n    const {\n        syncBody\n    } = usePhysicsConsumerContext()\n    // @ts-ignore\n    useLayoutEffect(() => {\n        if (!ref) return\n        if (!ref.current) {\n            ref.current = new Object3D()\n        }\n        return syncBody(id, ref as MutableRefObject<Object3D>, applyRotation)\n    }, [ref])\n}\n\nexport const useBody = (propsFn: () =>  any, options: Partial<Options> = {}, addToMessage?: (props: any, options: Partial<Options>) => any): [\n    MutableRefObject<Object3D>,\n    string\n] => {\n\n    const {sendMessage} = usePhysicsConsumerContext()\n    const [id] = useState(() => options.id ?? generateUUID())\n    const localRef = useRef<Object3D>(null as unknown as Object3D)\n\n    const {\n        prepareObject\n    } = usePhysicsConsumerHelpers() || {}\n\n    const [ref] = useState(() => options.ref || localRef)\n\n    useSyncBody(id, ref)\n\n    useLayoutEffect(() => {\n\n        const props = propsFn()\n\n        const object = ref.current\n\n        if (prepareObject) {\n            prepareObject(object, props)\n        }\n\n        sendMessage({\n            type: WorkerMessageType.ADD_BODY,\n            data: {\n                id,\n                props,\n                synced: options.synced ?? true,\n                ...(addToMessage ? addToMessage(props, options) : {})\n            },\n        })\n\n        return () => {\n            sendMessage({\n                type: WorkerMessageType.REMOVE_BODY,\n                data: {\n                    id,\n                },\n            })\n        }\n\n    }, [])\n\n    return [ref, id]\n\n}\n\nexport const usePlanckBody = (propsFn: () => AddBodyDef, options: Partial<Options> = {}): [\n    MutableRefObject<Object3D>,\n    string\n] => {\n    return useBody(propsFn, options)\n}","import React, {useEffect, useMemo} from \"react\"\nimport {WorkerMessageData, WorkerMessageType} from \"../../types\";\nimport {usePlanckAppContext} from \"../planckjs/PlanckApp.context\";\nimport {World} from \"cannon-es\";\nimport {AddBodyDef} from \"./types\";\nimport {createBody} from \"./bodies\";\n\nconst CannonPhysicsWorkerMessagesHandler: React.FC<{\n    world: World,\n    worker: Worker,\n}> = ({\n    world,\n                                                    worker,\n                                                }) => {\n\n    const {\n        addBody,\n        bodies,\n    } = usePlanckAppContext()\n\n    const {\n        handleAddBody,\n        handleModifyBody,\n    } = useMemo(() => ({\n        handleModifyBody: ({id, method, args}: {\n            id: string,\n            method: string,\n            args: any[],\n        }) => {\n            const body = bodies[id]\n            if (!body) {\n                console.warn(`No body found matching ${id}`)\n                return\n            }\n            (body as any)[method](...args)\n        },\n        handleAddBody: ({id, props, synced, listenForCollisions}: {\n            id: string,\n            props: AddBodyDef,\n            synced: boolean,\n            listenForCollisions?: boolean,\n        }) => {\n            const body = createBody(world, props)\n            // @ts-ignore\n            body.userData = {\n                id,\n                ...(props.userData ?? {}),\n            }\n            addBody(id, body, synced)\n            if (listenForCollisions) {\n                console.log('listenForCollisions')\n            }\n        }\n    }), [])\n\n    useEffect(() => {\n\n        const previousOnMessage: any = worker.onmessage\n\n        worker.onmessage = (event: any) => {\n\n            const message = event.data as WorkerMessageData\n\n            switch (message.type) {\n                case WorkerMessageType.ADD_BODY:\n                    handleAddBody(message.data)\n                    break;\n                case WorkerMessageType.MODIFY_BODY:\n                    handleModifyBody(message.data)\n                    break;\n            }\n\n            if (previousOnMessage) {\n                previousOnMessage(event)\n            }\n        }\n\n    }, [])\n\n    return null\n}\n\nexport default CannonPhysicsWorkerMessagesHandler","import {Body, Box, World, Sphere, Vec3} from \"cannon-es\";\nimport {AddBodyDef} from \"./types\";\n\nexport const createBody = (world: World, bodyDef: AddBodyDef) => {\n\n    const body = new Body(bodyDef.body);\n\n    bodyDef.shapes.forEach(({type, args}) => {\n        switch (type) {\n            case 'Box':\n                // @ts-ignore\n                const box = new Box(new Vec3(...args.map((v) => v / 2)))\n                body.addShape(box as unknown as any)\n                break;\n            case 'Sphere':\n                // @ts-ignore\n                const sphere = new Sphere(...args)\n                body.addShape(sphere as unknown as any)\n                break;\n            default:\n                break;\n        }\n    })\n    world.addBody(body);\n    return body;\n\n}","import {Body} from \"cannon-es\";\nimport {BodyData} from \"../../types\";\nimport {Object3D, Quaternion} from \"three\";\nimport {getNow} from \"../../../utils/time\";\nimport {lerp} from \"../../../utils/numbers\";\nimport { AddBodyDef } from \"./types\";\nimport { Buffers } from \"../planckjs/types\";\n\nexport const applyBufferData = (\n    buffers: Buffers,\n    syncedBodies: {\n        [key: string]: Body,\n    }, syncedBodiesOrder: string[]) => {\n\n    const {\n        positions,\n        angles,\n    } = buffers\n\n    syncedBodiesOrder.forEach((id, index) => {\n        const body = syncedBodies[id]\n        if (!body) return;\n        const position = body.position;\n        const quaternion = body.quaternion;\n        positions[3 * index + 0] = position.x\n        positions[3 * index + 1] = position.y\n        positions[3 * index + 2] = position.z\n        angles[4 * index + 0] = quaternion.x\n        angles[4 * index + 1] = quaternion.y\n        angles[4 * index + 2] = quaternion.z\n        angles[4 * index + 3] = quaternion.w\n    })\n\n}\n\nconst quat = new Quaternion()\n\nexport const lerpBody = (body: BodyData, object: Object3D, stepRate: number) => {\n    const {\n        position,\n        angle,\n        lastUpdate,\n        previous,\n    } = body\n\n    if (!position || !angle) return\n\n    if (!previous.position || !previous.angle) {\n        object.position.set(...position as [number, number, number])\n        object.quaternion.set(...angle as [number, number, number, number])\n        return\n    }\n\n    const now = getNow()\n\n    const nextExpectedUpdate = lastUpdate + stepRate + 1\n\n    const min = lastUpdate\n    const max = nextExpectedUpdate\n\n    let normalised = ((now - min) / (max - min))\n\n    normalised = normalised < 0 ? 0 : normalised > 1 ? 1 : normalised\n\n    const physicsRemainingRatio = normalised\n\n    object.position.x = lerp(\n        previous.position[0],\n        position[0],\n        physicsRemainingRatio\n    );\n\n    object.position.y = lerp(\n        previous.position[1],\n        position[1],\n        physicsRemainingRatio\n    );\n\n    object.position.z = lerp(\n        previous.position[2] as number,\n        position[2] as number,\n        physicsRemainingRatio\n    );\n\n    object.quaternion.fromArray(previous.angle as [number, number, number, number])\n    quat.fromArray(angle as [number, number, number, number])\n    object.quaternion.slerp(quat, physicsRemainingRatio)\n}\n\nconst getPositionAndAngle = (\n    buffers: Buffers,\n    index: number\n): {\n    position: [number, number, number];\n    angle: [number, number, number, number];\n} | null => {\n    if (index !== undefined && buffers.positions.length && buffers.angles.length) {\n        const start = index * 3;\n        const position = (buffers.positions.slice(start, start + 3) as unknown) as [\n            number,\n            number,\n            number,\n        ];\n        const angleStart = index * 4;\n        const angle = (buffers.angles.slice(angleStart, angleStart + 4) as unknown) as [\n            number,\n            number,\n            number,\n            number,\n        ];\n        return {\n            position,\n            angle,\n        };\n    } else {\n        return null;\n    }\n};\n\nexport const updateBodyData = (bodyData: BodyData, positions: Float32Array, angles: Float32Array) => {\n    bodyData.previous.position = bodyData.position\n    bodyData.previous.angle = bodyData.angle\n    const update = getPositionAndAngle({\n        positions,\n        angles,\n    }, bodyData.index)\n    if (update) {\n        bodyData.position = update.position\n        bodyData.angle = update.angle\n    }\n}\n\nexport const prepareObject = (object: Object3D, props: AddBodyDef) => {\n    if (props.body.position) {\n        object.position.set(...props.body.position.toArray())\n    }\n    if (props.body.quaternion) {\n        object.quaternion.set(...props.body.quaternion.toArray())\n    }\n}","import {Buffers} from \"../planckjs/types\";\n\nexport const generateBuffers = (maxNumberOfPhysicsObjects: number): Buffers => {\n    return {\n        positions: new Float32Array(maxNumberOfPhysicsObjects * 3),\n        angles: new Float32Array(maxNumberOfPhysicsObjects * 4),\n    };\n};\n","import { World, Body } from \"cannon-es\"\nimport React, {useCallback, useMemo, useRef} from \"react\"\nimport {getNow} from \"../../../utils/time\";\nimport Physics from \"../../Physics\";\nimport WorkerSubscription from \"../planckjs/WorkerSubscription\";\nimport {usePhysics} from \"../planckjs/PlanckPhysicsHandler\";\nimport {Context} from \"../planckjs/PlanckPhysicsHandler.context\";\nimport {Context as AppContext} from \"../planckjs/PlanckApp.context\";\nimport CannonPhysicsWorkerMessagesHandler from \"./CannonPhysicsWorkerMessagesHandler\";\nimport {applyBufferData} from \"./updates\";\nimport {generateBuffers} from \"./buffers\";\n\nconst CannonPhysicsHandler: React.FC<{\n    world: World,\n    worker: Worker,\n    stepRate: number,\n    maxNumberOfSyncedBodies: number,\n}> = ({children, world, stepRate, worker, maxNumberOfSyncedBodies}) => {\n\n    const removeBody = useCallback((body: Body) => {\n        world.removeBody(body)\n    }, [])\n\n    const {\n        subscribeToPhysicsUpdates,\n        getPendingSyncedBodiesIteration,\n        syncedBodies,\n        syncedBodiesOrder,\n        addSyncedBody,\n        removeSyncedBody,\n        addBody,\n        bodies,\n        onUpdate,\n    } = usePhysics(removeBody)\n\n    const localStateRef = useRef({\n        lastUpdate: getNow()\n    })\n\n    const {\n        onWorldStep\n    } = useMemo(() => ({\n        onWorldStep: () => {\n            const now = getNow()\n            const delta = (now - localStateRef.current.lastUpdate) / 1000;\n            localStateRef.current.lastUpdate = now;\n            world.step(stepRate / 1000, delta)\n            onUpdate()\n        }\n    }), [])\n\n    return (\n        <Context.Provider value={{\n            getPendingSyncedBodiesIteration,\n            syncedBodies,\n            syncedBodiesOrder,\n            maxNumberOfSyncedBodies,\n        }}>\n            <WorkerSubscription applyBufferData={applyBufferData} generateBuffers={generateBuffers}\n                                worker={worker} subscribe={subscribeToPhysicsUpdates}/>\n            <AppContext.Provider value={{\n                world,\n                addSyncedBody,\n                removeSyncedBody,\n                addBody,\n                bodies,\n            }}>\n                <CannonPhysicsWorkerMessagesHandler world={world} worker={worker}/>\n                <Physics onWorldStep={onWorldStep} stepRate={stepRate}>\n                    {children}\n                </Physics>\n            </AppContext.Provider>\n        </Context.Provider>\n    )\n}\n\nexport default CannonPhysicsHandler","import {AddBodyDef as CannonAddBodyDef} from \"./types\";\nimport {MutableRefObject} from \"react\";\nimport {Object3D} from \"three\";\nimport {Options, useBody} from \"../planckjs/hooks\";\n\n// @ts-ignore\nexport const addToMessage = (props: CannonAddBodyDef, options: Partial<Options>) => {\n    const message: {\n        [key: string]: any,\n    } = {}\n    if (options.listenForCollisions) {\n        message.listenForCollisions = true\n    }\n    return message\n}\n\nexport const useCannonBody = (propsFn: () => CannonAddBodyDef, options: Partial<Options> = {}): [\n    MutableRefObject<Object3D>,\n    string\n] => {\n    return useBody(propsFn, options, addToMessage)\n}","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import {Buffers} from \"../planckjs/types\";\nimport {RigidBody} from \"@dimforge/rapier3d-compat/rapier.js\";\nimport {Object3D} from \"three\";\nimport { AddBodyDef } from \"./types\";\n\nexport const applyBufferData = (\n    buffers: Buffers,\n    syncedBodies: {\n        [key: string]: RigidBody,\n    }, syncedBodiesOrder: string[]) => {\n\n    const {\n        positions,\n        angles,\n    } = buffers\n\n    syncedBodiesOrder.forEach((id, index) => {\n        const body = syncedBodies[id]\n        if (!body) return;\n        const position = body.translation();\n        const quaternion = body.rotation();\n        positions[3 * index + 0] = position.x\n        positions[3 * index + 1] = position.y\n        positions[3 * index + 2] = position.z\n        angles[4 * index + 0] = quaternion.x\n        angles[4 * index + 1] = quaternion.y\n        angles[4 * index + 2] = quaternion.z\n        angles[4 * index + 3] = quaternion.w\n    })\n\n}\n\nexport const prepareObject = (object: Object3D, props: AddBodyDef) => {\n    if (props.body.position) {\n        object.position.set(...props.body.position as [number, number, number])\n    }\n    if (props.body.quaternion) {\n        object.quaternion.set(...props.body.quaternion as [number, number, number, number])\n    }\n}","import {World, RigidBodyDesc, ColliderDesc, RigidBody} from \"@dimforge/rapier3d-compat/rapier.js\";\nimport {AddBodyDef, ColliderDef} from \"./types\";\n\nconst createColliderDesc = (colliderDef: ColliderDef): ColliderDesc | null => {\n    switch (colliderDef.type) {\n        case \"Ball\":\n            // @ts-ignore\n            return ColliderDesc.ball(...colliderDef.args);\n        case \"Cubiod\":\n            // @ts-ignore\n            return ColliderDesc.cuboid(...colliderDef.args);\n    }\n    return null\n}\n\n// const getCollisionGroups = (myGroups: number[], interactGroups: number[]) => {\n//     let result = 0;\n//     for (let g of myGroups)\n//     {\n//         result += (1 << g);\n//     }\n//     result = result << 16;\n//\n//     for (let f of interactGroups)\n//     {\n//         result += (1 << f);\n//     }\n//     return result;\n// }\n\nconst createCollider = (world: World, body: RigidBody, colliderDef: ColliderDef) => {\n    const collider = createColliderDesc(colliderDef)\n    if (!collider) return\n    world.createCollider(collider, body.handle)\n}\n\nexport const removeBody = (world: World, body: RigidBody) => {\n    world.removeRigidBody(body)\n}\n\nexport const createBody = (world: World, bodyDef: AddBodyDef) => {\n\n    const rigidBodyDesc = new RigidBodyDesc(bodyDef.body.type);\n\n    if (bodyDef.body.mass != undefined) {\n        rigidBodyDesc.setMass(bodyDef.body.mass)\n    }\n    if (bodyDef.body.position) {\n        rigidBodyDesc.setTranslation(...(bodyDef.body.position as [number, number, number]))\n    }\n    if (bodyDef.body.quaternion) {\n        rigidBodyDesc.setRotation({\n            x: bodyDef.body.quaternion[0],\n            y: bodyDef.body.quaternion[1],\n            z: bodyDef.body.quaternion[2],\n            w: bodyDef.body.quaternion[3],\n        })\n    }\n    const body = world.createRigidBody(rigidBodyDesc);\n\n    bodyDef.colliders.forEach((collider) => {\n        createCollider(world, body, collider)\n    })\n\n    return body\n\n}","import {AddBodyDef} from \"./types\";\n\nexport type CustomBodyModifiers = {\n    [key: string]: (body: any) => void,\n}\n\nexport const customData: {\n    customBodyModifiers: CustomBodyModifiers,\n} = {\n    customBodyModifiers: {},\n}\n\nexport const getCustomBodyModifier = (bodyDef: AddBodyDef) => {\n    if (bodyDef.customBody && customData.customBodyModifiers[bodyDef.customBody]) {\n        return customData.customBodyModifiers[bodyDef.customBody]\n    }\n    return undefined\n}","import React, {useEffect, useMemo, useRef} from \"react\"\nimport {World} from \"@dimforge/rapier3d-compat/rapier.js\";\nimport {usePlanckAppContext} from \"../planckjs/PlanckApp.context\";\nimport {WorkerMessageData, WorkerMessageType} from \"../../types\";\nimport {AddBodyDef} from \"./types\";\nimport {createBody} from \"./bodies\";\nimport {getCustomBodyModifier} from \"./custom\";\n\nconst Rapier3DPhysicsWorkerMessagesHandler: React.FC<{\n    world: World,\n    worker: Worker,\n}> = ({\n    world,\n    worker,\n    }) => {\n\n    const {\n        addBody,\n        bodies,\n    } = usePlanckAppContext()\n\n    const localStateRef = useRef<{\n        removeCallbacks: {\n            [key: string]: () => void,\n        }\n    }>({\n        removeCallbacks: {},\n    })\n\n    const {\n        handleAddBody,\n        handleModifyBody,\n        handleRemoveBody,\n    } = useMemo(() => ({\n        handleModifyBody: ({id, method, args}: {\n            id: string,\n            method: string,\n            args: any[],\n        }) => {\n            const body = bodies[id]\n            if (!body) {\n                console.warn(`No body found matching ${id}`)\n                return\n            }\n            (body as any)[method](...args)\n        },\n        handleAddBody: ({id, props, synced}: {\n            id: string,\n            props: AddBodyDef,\n            synced: boolean,\n            listenForCollisions?: boolean,\n        }) => {\n            const body = createBody(world, props)\n            const customModifier = getCustomBodyModifier(props)\n            if (customModifier) {\n                customModifier(body)\n            }\n            localStateRef.current.removeCallbacks[id] = addBody(id, body, synced)\n        },\n        handleRemoveBody: ({id}: {\n            id: string\n        }) => {\n            const body = bodies[id]\n            world.removeRigidBody(body)\n            if (localStateRef.current.removeCallbacks[id]) {\n                localStateRef.current.removeCallbacks[id]()\n            }\n        }\n    }), [])\n\n    useEffect(() => {\n\n        const previousOnMessage: any = worker.onmessage\n\n        worker.onmessage = (event: any) => {\n\n            const message = event.data as WorkerMessageData\n\n            switch (message.type) {\n                case WorkerMessageType.ADD_BODY:\n                    handleAddBody(message.data)\n                    break;\n                case WorkerMessageType.REMOVE_BODY:\n                    handleRemoveBody(message.data)\n                    break;\n                case WorkerMessageType.MODIFY_BODY:\n                    handleModifyBody(message.data)\n                    break;\n            }\n\n            if (previousOnMessage) {\n                previousOnMessage(event)\n            }\n        }\n\n    }, [])\n\n    return null\n}\n\nexport default Rapier3DPhysicsWorkerMessagesHandler","import React, {useCallback, useMemo, useState} from \"react\"\nimport {World} from \"@dimforge/rapier3d-compat/rapier.js\";\nimport {usePhysics} from \"../planckjs/PlanckPhysicsHandler\";\nimport {Context} from \"../planckjs/PlanckPhysicsHandler.context\";\nimport WorkerSubscription from \"../planckjs/WorkerSubscription\";\nimport {generateBuffers} from \"../cannon/buffers\";\nimport {Context as AppContext} from \"../planckjs/PlanckApp.context\";\nimport Physics from \"../../Physics\";\nimport {applyBufferData} from \"./updates\";\nimport Rapier3DPhysicsWorkerMessagesHandler from \"./Rapier3DPhysicsWorkerMessagesHandler\";\nimport {removeBody} from \"./bodies\";\n\nconst Rapier3DPhysicsHandler: React.FC<{\n    world: World,\n    worker: Worker,\n    stepRate: number,\n    maxNumberOfSyncedBodies: number,\n}> = ({\n    children,\n    world,\n    stepRate,\n    worker,\n    maxNumberOfSyncedBodies\n}) => {\n\n    const customRemoveBody = useCallback((body: any) => {\n        removeBody(world, body)\n    }, [])\n\n    const {\n        subscribeToPhysicsUpdates,\n        getPendingSyncedBodiesIteration,\n        syncedBodies,\n        syncedBodiesOrder,\n        addSyncedBody,\n        removeSyncedBody,\n        addBody,\n        bodies,\n        onUpdate,\n    } = usePhysics(customRemoveBody)\n\n    const [paused, setPaused] = useState(false)\n\n    const {\n        onWorldStep\n    } = useMemo(() => ({\n        onWorldStep: () => {\n            if (paused) return\n            world.step()\n            onUpdate()\n        }\n    }), [paused])\n\n    return (\n        <Context.Provider value={{\n            getPendingSyncedBodiesIteration,\n            syncedBodies,\n            syncedBodiesOrder,\n            maxNumberOfSyncedBodies,\n        }}>\n            <WorkerSubscription applyBufferData={applyBufferData} generateBuffers={generateBuffers}\n                                worker={worker} subscribe={subscribeToPhysicsUpdates} setPaused={setPaused}/>\n            <AppContext.Provider value={{\n                world,\n                addSyncedBody,\n                removeSyncedBody,\n                addBody,\n                bodies,\n            }}>\n                <Rapier3DPhysicsWorkerMessagesHandler world={world} worker={worker}/>\n                <Physics onWorldStep={onWorldStep} stepRate={stepRate}>\n                    {children}\n                </Physics>\n            </AppContext.Provider>\n        </Context.Provider>\n    )\n}\n\nexport default Rapier3DPhysicsHandler","import { World } from \"cannon-es\"\nimport React, {useEffect, useState} from \"react\"\nimport CannonPhysicsHandler from \"./CannonPhysicsHandler\";\nimport {DEFAULT_STEP_RATE} from \"../../config\";\nimport {WorkerMessaging} from \"../../../generic\";\n\nconst useCannonPhysics = () => {\n\n    const [world, setWorld] = useState<World | null>(null)\n\n    useEffect(() => {\n\n        const cannonWorld = new World()\n        cannonWorld.gravity.set(0, -9.81, 0)\n        setWorld(cannonWorld)\n\n        cannonWorld.addEventListener('beginContact', () => {\n            // todo\n        })\n\n        cannonWorld.addEventListener('endContact', () => {\n            // todo\n        })\n\n    }, [])\n\n    return {\n        world,\n    }\n\n}\n\nconst CannonApp: React.FC<{\n    worker: Worker,\n    stepRate?: number,\n    maxNumberOfSyncedBodies?: number,\n}> = ({\n                           children,\n                           stepRate = DEFAULT_STEP_RATE,\n                           maxNumberOfSyncedBodies = 100,\n                           worker}) => {\n\n    const {world} = useCannonPhysics()\n\n    if (!world) return null\n\n    return (\n        <WorkerMessaging worker={worker}>\n            <CannonPhysicsHandler world={world} worker={worker} stepRate={stepRate} maxNumberOfSyncedBodies={maxNumberOfSyncedBodies}>\n                {children}\n            </CannonPhysicsHandler>\n        </WorkerMessaging>\n    )\n}\n\nexport default CannonApp","import React from \"react\"\nimport {PhysicsConsumer} from \"../../../index\";\nimport {lerpBody, prepareObject, updateBodyData} from \"./updates\";\nimport PhysicsConsumerHelpers from \"../planckjs/PhysicsConsumerHelpers\";\n\nconst CannonPhysicsConsumer: React.FC<{\n    worker: Worker,\n    stepRate: number,\n}> = ({worker, stepRate, children}) => {\n    return (\n        <PhysicsConsumer updateBodyData={updateBodyData} lerpBody={lerpBody} worker={worker} stepRate={stepRate}>\n            <PhysicsConsumerHelpers prepareObject={prepareObject}>\n                {children}\n            </PhysicsConsumerHelpers>\n        </PhysicsConsumer>\n    )\n}\n\nexport default CannonPhysicsConsumer","import React, { useEffect, useState} from \"react\";\nimport {World} from \"planck-js\";\nimport {DEFAULT_STEP_RATE} from \"../../config\";\nimport PlanckPhysicsHandler from \"./PlanckPhysicsHandler\";\nimport {WorkerMessaging} from \"../../../generic\";\n\nconst usePlanckPhysics = () => {\n\n    const [world, setWorld] = useState<World | null>(null)\n\n    useEffect(() => {\n        const planckWorld = new World({allowSleep: false})\n        setWorld(planckWorld)\n    }, [])\n\n    return {\n        world,\n    }\n}\n\nconst PlanckApp: React.FC<{\n    worker: Worker,\n    stepRate?: number,\n    maxNumberOfSyncedBodies?: number,\n}> = ({children,\n                           stepRate = DEFAULT_STEP_RATE,\n                           maxNumberOfSyncedBodies = 100,\n                           worker}) => {\n\n    const {world} = usePlanckPhysics()\n\n    if (!world) return null\n\n    return (\n        <WorkerMessaging worker={worker}>\n            <PlanckPhysicsHandler world={world} worker={worker} stepRate={stepRate} maxNumberOfSyncedBodies={maxNumberOfSyncedBodies}>\n                {children}\n            </PlanckPhysicsHandler>\n        </WorkerMessaging>\n    );\n};\n\nexport default PlanckApp;","import React from \"react\"\nimport {PhysicsConsumer} from \"../../../index\";\nimport {lerpBody, prepareObject, updateBodyData} from \"./updates\";\nimport PhysicsConsumerHelpers from \"./PhysicsConsumerHelpers\";\n\nconst PlanckPhysicsConsumer: React.FC<{\n    worker: Worker,\n    stepRate: number,\n}> = ({worker, stepRate, children}) => {\n    return (\n        <PhysicsConsumer updateBodyData={updateBodyData} lerpBody={lerpBody} worker={worker} stepRate={stepRate}>\n            <PhysicsConsumerHelpers prepareObject={prepareObject}>\n                {children}\n            </PhysicsConsumerHelpers>\n        </PhysicsConsumer>\n    )\n}\n\nexport default PlanckPhysicsConsumer","import React, {useCallback, useEffect, useState} from \"react\"\nimport * as RAPIER from \"@dimforge/rapier3d-compat/rapier.js\"\nimport {DEFAULT_STEP_RATE} from \"../../config\";\nimport Rapier3DPhysicsHandler from \"./Rapier3DPhysicsHandler\";\nimport {CustomBodyModifiers, customData} from \"./custom\";\nimport {WorkerMessaging} from \"../../../generic\";\n\nconst useRapier3dPhysics = (stepRate: number) => {\n\n    const [world, setWorld] = useState<RAPIER.World | null>(null)\n\n    const init = useCallback(async () => {\n        // @ts-ignore\n        await RAPIER.init()\n\n        const gravity = new RAPIER.Vector3(0.0, -9.81, 0.0);\n        const rapierWorld = new RAPIER.World(gravity);\n        rapierWorld.timestep = stepRate / 1000\n        setWorld(rapierWorld)\n\n    }, [])\n\n    useEffect(() => {\n        init()\n    }, [])\n\n    return {\n        world,\n    }\n\n}\n\nconst Rapier3DApp: React.FC<{\n    worker: Worker,\n    stepRate?: number,\n    maxNumberOfSyncedBodies?: number,\n    customBodyModifiers?: CustomBodyModifiers\n}> = ({\n                             children,\n                             stepRate = DEFAULT_STEP_RATE,\n                             maxNumberOfSyncedBodies = 100,\n                             customBodyModifiers = {},\n                             worker}) => {\n\n    const {world} = useRapier3dPhysics(stepRate)\n\n    useEffect(() => {\n        customData.customBodyModifiers = customBodyModifiers\n    }, [customBodyModifiers])\n\n    if (!world) return null\n\n    return (\n        <WorkerMessaging worker={worker}>\n            <Rapier3DPhysicsHandler world={world} worker={worker} stepRate={stepRate} maxNumberOfSyncedBodies={maxNumberOfSyncedBodies}>\n                {children}\n            </Rapier3DPhysicsHandler>\n        </WorkerMessaging>\n    )\n}\n\nexport default Rapier3DApp","import React from \"react\"\nimport {lerpBody, updateBodyData} from \"../cannon/updates\";\nimport PhysicsConsumerHelpers from \"../planckjs/PhysicsConsumerHelpers\";\nimport {PhysicsConsumer} from \"../../../index\";\nimport {prepareObject} from \"./updates\";\nimport {DefaultPhysicsConsumerProps} from \"../../PhysicsConsumer\";\n\nconst Rapier3DPhysicsConsumer: React.FC<DefaultPhysicsConsumerProps> = ({children, ...props}) => {\n    return (\n        <PhysicsConsumer updateBodyData={updateBodyData} lerpBody={lerpBody} {...props}>\n            <PhysicsConsumerHelpers prepareObject={prepareObject}>\n                {children}\n            </PhysicsConsumerHelpers>\n        </PhysicsConsumer>\n    )\n}\n\nexport default Rapier3DPhysicsConsumer","import {render} from \"react-nil\";\nimport {createElement, FC} from \"react\";\n\nexport const createWorkerApp = (app: FC<{\n    worker?: Worker,\n}>) => {\n    render(createElement(app, {\n        worker: self as unknown as Worker,\n    }), null)\n}","import {Options, useBody} from \"../planckjs/hooks\";\nimport {MutableRefObject} from \"react\";\nimport {Object3D} from \"three\";\nimport {addToMessage} from \"../cannon/hooks\";\nimport {AddBodyDef} from \"./types\";\n\nexport const useRapier3DBody = (propsFn: () => AddBodyDef, options: Partial<Options> = {}): [\n    MutableRefObject<Object3D>,\n    string\n] => {\n    return useBody(propsFn, options, addToMessage)\n}"],"names":["WorkerMessageType","Context","createContext","start","Date","now","getNow","performance","usePhysicsConsumerContext","useContext","MessageType","generateUUID","MathUtils","useActiveKeys","create","activeKeys","rawActiveKeys","setActiveKey","code","active","setState","state","FixtureShape","SyncedComponentProp","propKey","id","value","sendMessage","firstUpdateRef","useRef","useEffect","current","message","propUpdate","propRemoved","WorkerMessaging","worker","children","useCallback","postMessage","type","CUSTOM","previousOnMessage","onmessage","event","data","keyCode","useHandleKeyEvents","React","Provider","FixedUpdateContext","useFixedUpdateContext","OnFixedUpdateProvider","localStateRef","subscriptionsIterator","onFixedUpdateSubscriptions","useMemo","subscribeToOnPhysicsUpdate","callback","toString","updateSubscriptions","delta","Object","values","forEach","PhysicsConsumer","paused","updateBodyData","stepRate","lerpBody","useState","connected","setConnected","bodiesData","lastUpdate","bodies","onFrameCallbacks","lerpMesh","body","ref","onUpdate","updateTime","positions","angles","entries","bodyData","index","indexOf","interval","setInterval","PHYSICS_READY","clearInterval","PHYSICS_SET_PAUSED","PHYSICS_ACKNOWLEDGED","PHYSICS_UPDATE","PHYSICS_PROCESSED","buffer","syncBody","applyRotation","lastRender","previous","syncMeshes","onKeyDown","repeat","key","onKeyUp","window","addEventListener","removeEventListener","useTransferKeyEvents","PhysicsConsumerSyncMeshes","useRAF","Wrapper","props","PhysicsProvider","onWorldStep","stepWorld","stepWorldRef","Worker","encodeURIComponent","createNewPhysicsLoopWebWorker","Physics","usePlanckAppContext","WorkerSubscription","subscribe","applyBufferData","generateBuffers","setPaused","getPendingSyncedBodiesIteration","syncedBodies","syncedBodiesOrder","maxNumberOfSyncedBodies","buffers","bodiesIteration","buffersAvailable","setBuffersAvailable","updateCount","setUpdateCount","updateWorker","update","shouldSyncBodies","updateWorkerRef","onUpdateRef","PlanckPhysicsWorkerMessagesHandler","world","addBody","handleModifyBody","method","args","console","warn","handleAddBody","synced","bodyDef","fixtures","createBody","fixtureOptions","fixtureShape","shape","Circle","Box","createFixtureShape","createFixture","ADD_BODY","MODIFY_BODY","lerp","object","position","angle","undefined","x","z","rotation","normalised","physicsRemainingRatio","y","length","slice","getPositionAndAngle","getPosition","getAngle","prepareObject","maxNumberOfPhysicsObjects","Float32Array","usePhysics","removeBody","countRef","workerSubscriptionsRef","subscribeToPhysicsUpdates","hasPendingSyncedBodiesRef","addSyncedBody","uid","push","splice","removeSyncedBody","syncedUnsub","usePhysicsBodies","PlanckPhysicsHandler","destroyBody","step","clearForces","AppContext","RAFSync","useFrame","IntervalSync","PhysicsConsumerHelpers","useSyncBody","options","useLayoutEffect","Object3D","useBody","propsFn","addToMessage","localRef","REMOVE_BODY","CannonPhysicsWorkerMessagesHandler","listenForCollisions","Body","shapes","box","Vec3","map","v","addShape","sphere","Sphere","userData","log","quaternion","w","quat","Quaternion","set","fromArray","slerp","angleStart","toArray","CannonPhysicsHandler","runtime","exports","Op","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","Generator","context","_invoke","arg","Error","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","translation","rigidBodyDesc","RigidBodyDesc","mass","setMass","setTranslation","setRotation","createRigidBody","colliders","collider","colliderDef","ColliderDesc","ball","cuboid","createColliderDesc","createCollider","customData","customBodyModifiers","Rapier3DPhysicsWorkerMessagesHandler","removeCallbacks","customModifier","customBody","getCustomBodyModifier","handleRemoveBody","removeRigidBody","Rapier3DPhysicsHandler","customRemoveBody","setWorld","cannonWorld","World","gravity","useCannonPhysics","planckWorld","allowSleep","usePlanckPhysics","init","RAPIER","rapierWorld","timestep","useRapier3dPhysics","components","storedComponents","setComponents","handleCustomMessage","mounted","unmounted","updated","existing","updatedProps","component","Component","passedId","useSyncComponent","app","render","createElement","callbackRef"],"mappings":"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"}